<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>dev/seeds/prepare-seeds.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AdministratorService.html">AdministratorService</a><ul class='methods'><li data-type='method'><a href="AdministratorService.html#.afterRemoteLogin">afterRemoteLogin</a></li><li data-type='method'><a href="AdministratorService.html#.beforeRemoteCreate">beforeRemoteCreate</a></li></ul></li><li><a href="CustomerService.html">CustomerService</a><ul class='methods'><li data-type='method'><a href="CustomerService.html#.afterRemoteLogin">afterRemoteLogin</a></li><li data-type='method'><a href="CustomerService.html#.beforeRemoteCreate">beforeRemoteCreate</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-Migrations_Reset.html">Migrations/Reset</a><ul class='methods'><li data-type='method'><a href="module-Migrations_Reset.html#~runModelsMigrations">runModelsMigrations</a></li></ul></li><li><a href="module-Migrations_Update.html">Migrations/Update</a><ul class='methods'><li data-type='method'><a href="module-Migrations_Update.html#~runModelsAutopdate">runModelsAutopdate</a></li></ul></li><li><a href="module-Roles_Resolver.html">Roles/Resolver</a></li><li><a href="module-Seeds_Execute.html">Seeds/Execute</a><ul class='methods'><li data-type='method'><a href="module-Seeds_Execute.html#~areThereSeedFilesModels">areThereSeedFilesModels</a></li><li data-type='method'><a href="module-Seeds_Execute.html#~checkIfDirectoryExists">checkIfDirectoryExists</a></li><li data-type='method'><a href="module-Seeds_Execute.html#~getModelsSeedsFromSeedJSONModels">getModelsSeedsFromSeedJSONModels</a></li><li data-type='method'><a href="module-Seeds_Execute.html#~isTheFolderEmpty">isTheFolderEmpty</a></li><li data-type='method'><a href="module-Seeds_Execute.html#~performSimpleSeed">performSimpleSeed</a></li><li data-type='method'><a href="module-Seeds_Execute.html#~seedModel">seedModel</a></li></ul></li><li><a href="module-Seeds_Execute_ComplexSeed.html">Seeds/Execute/ComplexSeed</a><ul class='methods'><li data-type='method'><a href="module-Seeds_Execute_ComplexSeed.html#~addHasManyFakeRelatedModels">addHasManyFakeRelatedModels</a></li><li data-type='method'><a href="module-Seeds_Execute_ComplexSeed.html#~flattenArray">flattenArray</a></li><li data-type='method'><a href="module-Seeds_Execute_ComplexSeed.html#~getSeedModelByName">getSeedModelByName</a></li><li data-type='method'><a href="module-Seeds_Execute_ComplexSeed.html#~insert">insert</a></li><li data-type='method'><a href="module-Seeds_Execute_ComplexSeed.html#~insertBelongsTo">insertBelongsTo</a></li><li data-type='method'><a href="module-Seeds_Execute_ComplexSeed.html#~insertHasManyRelatedModels">insertHasManyRelatedModels</a></li><li data-type='method'><a href="module-Seeds_Execute_ComplexSeed.html#~insertMainParentRecords">insertMainParentRecords</a></li><li data-type='method'><a href="module-Seeds_Execute_ComplexSeed.html#~performComplexSeed">performComplexSeed</a></li></ul></li><li><a href="module-Seeds_Prepare.html">Seeds/Prepare</a><ul class='methods'><li data-type='method'><a href="module-Seeds_Prepare.html#~bootstrapFuction">bootstrapFuction</a></li><li data-type='method'><a href="module-Seeds_Prepare.html#~checkIfDirectoryExists">checkIfDirectoryExists</a></li><li data-type='method'><a href="module-Seeds_Prepare.html#~checkJSONSeedsAvailability">checkJSONSeedsAvailability</a></li><li data-type='method'><a href="module-Seeds_Prepare.html#~getModelsContentFromJSONs">getModelsContentFromJSONs</a></li><li data-type='method'><a href="module-Seeds_Prepare.html#~keepPropetiesFromJSONSeedModelsUpToDate">keepPropetiesFromJSONSeedModelsUpToDate</a></li><li data-type='method'><a href="module-Seeds_Prepare.html#~prepareSeedsModels">prepareSeedsModels</a></li><li data-type='method'><a href="module-Seeds_Prepare.html#~writeRemainingJSONFiles">writeRemainingJSONFiles</a></li></ul></li><li><a href="module-Seeds_Roles.html">Seeds/Roles</a><ul class='methods'><li data-type='method'><a href="module-Seeds_Roles.html#~createRole">createRole</a></li></ul></li><li><a href="module-Seeds_Utils_Shared.html">Seeds/Utils/Shared</a><ul class='methods'><li data-type='method'><a href="module-Seeds_Utils_Shared.html#~areAllpropertiesSeedsFilled">areAllpropertiesSeedsFilled</a></li><li data-type='method'><a href="module-Seeds_Utils_Shared.html#~getFakeModelsArray">getFakeModelsArray</a></li><li data-type='method'><a href="module-Seeds_Utils_Shared.html#~getRandomElementFromArray">getRandomElementFromArray</a></li><li data-type='method'><a href="module-Seeds_Utils_Shared.html#~getRelationsTypeFromLoopbackModel">getRelationsTypeFromLoopbackModel</a></li><li data-type='method'><a href="module-Seeds_Utils_Shared.html#~typeOfSeedToGenerate">typeOfSeedToGenerate</a></li></ul></li><li><a href="module-Seeds_Utils_Terminal_Console.html">Seeds/Utils/Terminal/Console</a><ul class='methods'><li data-type='method'><a href="module-Seeds_Utils_Terminal_Console.html#~logMessage">logMessage</a></li><li data-type='method'><a href="module-Seeds_Utils_Terminal_Console.html#~logProcess">logProcess</a></li><li data-type='method'><a href="module-Seeds_Utils_Terminal_Console.html#~printBanner">printBanner</a></li></ul></li><li><a href="module-Seeds_Utils_Terminal_Inquirer.html">Seeds/Utils/Terminal/Inquirer</a></li><li><a href="module-Shared_ModelsUtils.html">Shared/ModelsUtils</a><ul class='methods'><li data-type='method'><a href="module-Shared_ModelsUtils.html#~getModelsContentFromJSONs">getModelsContentFromJSONs</a></li><li data-type='method'><a href="module-Shared_ModelsUtils.html#~getModelsWithRequestedProperties">getModelsWithRequestedProperties</a></li><li data-type='method'><a href="module-Shared_ModelsUtils.html#~getNameModelsArray">getNameModelsArray</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">dev/seeds/prepare-seeds.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Prepares all the JSON seed files in order to generate fake
 * data for the Loopback's model that are allocated on the common folder.
 * The output that generate is a JSON file per Loopback model file that
 * allows the user to enter faker.js' mustache syntax to generate all 
 * kind of fake data to test his or her applications.
 * @module Seeds/Prepare 
 * @author Marcos Barrera del Río &lt;elyomarcos@gmail.com>
 */

const asyncSeries = require('async').series;
const fileExists = require('file-exists');
const mkdirp = require('mkdirp');
const readfiles = require('node-readfiles');

const { logMessage } = require('./utils/terminal/console');


/**
 * The absolute path in which the JSON models seeds with be written.
 * @type {string}
 */
const seedsDirectory = '/dev/seeds/seedModels/';


/**
 * The main array which several methods across the module will have access to.
 * @type {Object[]}
 */
let arrayModels = [];


/**
 * This function is the one that starts all the process in this file, by running 
 * all the other functions in the proper order one by one, one after the other.
 * @author Marcos Barrera del Río &lt;elyomarcos@gmail.com>
 */
function bootstrapFuction() {

  asyncSeries([
    cb => getModelsContentFromJSONs(cb),
    cb => prepareSeedsModels(cb),
    cb => checkIfDirectoryExists(cb),
    cb => checkJSONSeedsAvailability(cb),
    cb => keepPropetiesFromJSONSeedModelsUpToDate(cb),
    cb => writeRemainingJSONFiles(cb),
  ], (err, results) => {
    if(err) {

      logMessage({ color: 'redBright', bold: true ,message: err, error: true });
      logMessage({ 
        color: 'cyanBright', 
        bold: true, 
        message: '\n-----There previous error forced the Seed Process to be stopped.-----\n'
     });

    } else {
      
      logMessage({ 
        color: 'greenBright', bold: true,
        message: '\nTodo bien, men. All the seed files were created and updated successfully :)\n'
      });

      process.exit(0);

    }
    
  
  });

}


/**
 * Get all the Custom Loopback's models and processes them to only get the 
 * model &lt;code>name&lt;/code>, the model &lt;code>filename&lt;/code> and the
 * model &lt;code>properties&lt;/code> to push it inside the &lt;code>arrayModels&lt;/code>
 * array.
 * @author Marcos Barrera del Río &lt;elyomarcos@gmail.com>
 * @param {callback} cb - The next callback to keep the flow on all the 
 * &lt;code>prepare process&lt;/code> on the file.
 * @example
 * //The arrayModels shape at this point.
 * arrayModels:  [
 *   {
 *     "filename": "model1.json",
 *     "name": "Model1",
 *     "properties_seeds": [
 *       "id",
 *       "name",
 *       "last_name",
 *     ]
 *   },
 *   //... more models
 * ]
 */
function getModelsContentFromJSONs(cb) {

  readfiles('./common/models/', { filter: '*.json' }, (err, filename, contents) => {
    if (err) throw err;

    let json = {
      filename,
      name: JSON.parse(contents).name,
      properties_seeds: Object.keys(JSON.parse(contents).properties)
    }

    arrayModels.push(json);
  })
  .then(files => {
    return cb(null)})
  .catch(err => {
    console.log('Error reading files:', err.message);
    cb(err);
  });

}


/**
 * Get all the previous processed models from the &lt;code>arrayModels&lt;/code> array
 * and generate the &lt;code>properties_seeds&lt;/code> property on each
 * one of them with the wanted shape in order to allow the seeder to introduces
 * mustache syntax strings in each on of the properties from every model.
 * @author Marcos Barrera del Río &lt;elyomarcos@gmail.com>
 * @param {callback} cb - The next callback to keep the flow on all the 
 * &lt;b>prepare process&lt;/b> on the file.
 * @example
 * {
 *  "filename": "routine.json",
 *  "name": "Routine",
 *  "properties_seeds": [
 *    {
 *      "description": ""
 *    }
 *  ]
 * }
 */
function prepareSeedsModels(cb) {
  arrayModels.forEach(model =>
    model.properties_seeds = model.properties_seeds.map(prop =>
      prop = { [prop]: "" }
    )
  );
  cb(null);
}


/**
 * Simple function that checks whether the current directory from the 
 * &lt;code>seedsDirectory&lt;/code> cons actually exists. If not, it creates it.
 * @author Marcos Barrera del Río &lt;elyomarcos@gmail.com>
 * @param {callback} cb - The next callback to keep the flow on all the 
 * &lt;b>prepare process&lt;/b> on the file.
 * 
 */
function checkIfDirectoryExists( cb ) {
  mkdirp(`.${seedsDirectory}`, (err) => {
    if (err) cb( err );
    cb( null );
  });
}


/**
 * Checks on by one if each model from the &lt;code>arrayModels&lt;/code> array
 * currently exists as a JSON seed file. If some mode already exists, then
 * the &lt;code>hasToBeModifiedOrAdded&lt;/code> property is added depending of
 * the result.
 * @author Marcos Barrera del Río &lt;elyomarcos@gmail.com>
 * @prop {boolean} model.hasToBeModifiedOrAdded 
 * @param {callback} cb - The next callback to keep the flow on all the 
 * &lt;b>prepare process&lt;/b> on the file.
 * 
 */
function checkJSONSeedsAvailability(cb) {

  let promises = [];
  arrayModels.forEach(model => {
    promises.push(
      fileExists(`.${seedsDirectory}seed-${model.filename}`).then(exists => {
        model.hasToBeModifiedOrAdded = !exists;
        // console.log(exists); // OUTPUTS: true or false
      })
    )
  })

  Promise.all(promises).then(() => cb(null));
}


/**
 * Checks if the current JSON Seed models are up to date. Deletes all the properties
 * from the JSON seed files that are not showed on the main Loopback models and also
 * add to the JSON seed files all the new properties that exists on the main Loopback
 * models.
 * @author Marcos Barrera del Río &lt;elyomarcos@gmail.com>
 * @param {callback} cb - The next callback to keep the flow on all the 
 * &lt;b>prepare process&lt;/b> on the file.
 * 
 */
function keepPropetiesFromJSONSeedModelsUpToDate( cb ) {

  readfiles(`.${seedsDirectory}`, { filter: '*.json' }, (err, filename, jsonString) => {

    //Parsed to an object the previous JSON seed file.
    const seedObject = JSON.parse(jsonString);

    //Get current object seed from array to check if they have the same properties.
    const objectFromArrayModelsIndex = arrayModels.findIndex( model => {
      return seedObject.name === model.name
    });

    const objectFromArrayModels = arrayModels[objectFromArrayModelsIndex];
    
    //Get every property of the previous seed object on a new array.
    const currentSeedProperties = seedObject.properties_seeds.map( prop => {
      return Object.keys(prop)[0];
    });

    //Get every property of the current seed object on a new array.
    const currentModelProperties = objectFromArrayModels.properties_seeds.map( prop => {
      return Object.keys(prop)[0];
    });


    (function addNewPropertiesToTheSeedJSONModels() {
      
      //Get an array of all the properties that have to be added to the seed model.
      const newPropertiesToWrite = currentModelProperties.filter(val => {
        return !currentSeedProperties.includes(val);
      });
      
      
      if(newPropertiesToWrite.length > 0) {
        
        //Get current model from main array.
        let current = arrayModels[objectFromArrayModelsIndex];

        //Create an object to be added to the curretn properties_seeds on the seed model.
        let newPropertiesObject = newPropertiesToWrite.map( prop => { 
          return {[prop] : ""} 
        });
        
        //Added all new properties to the current JSON model that will be re-write.
        current.properties_seeds = [ ...newPropertiesObject, ...seedObject.properties_seeds ];
        current.hasToBeModifiedOrAdded = true;
      }

    })();


    (function deleteLeftoverPropertiesFromSeedJSONModels() {
      //Get an array of all the properties that have to be deleted from the seed model.
      const leftoverPropertiesToDelete = currentSeedProperties.filter(val => {
        return !currentModelProperties.includes(val);
      });


      if(leftoverPropertiesToDelete.length > 0) {

        //Get current model from main array.
        let current = arrayModels[objectFromArrayModelsIndex];

        leftoverPropertiesToDelete.forEach( prop => {
          let indexToDelete;

          seedObject.properties_seeds.forEach((currentPropObject, i) => {
            
            if(Object.keys(currentPropObject)[0] === prop)
              indexToDelete = i;
          
            });

          //Delete the property fro the property seed array of the current seed model.
          seedObject.properties_seeds.splice(indexToDelete, 1);

          indexToDelete = null;

        })
        
        current.properties_seeds = [ ...seedObject.properties_seeds ];
        current.hasToBeModifiedOrAdded = true;
        
      }
    })();
    

  })
  .then(files => cb(null))
  .catch(err => {
    console.log('Error reading files:', err.message);
    cb(err);
  });

}


/**
 * Writes all the new seed models or modified the ones that have new properties or
 * the ones that have unnecesary properties (for example, properties that not longer
 * exists on the main Loopback model of a given seed model).
 * @author Marcos Barrera del Río &lt;elyomarcos@gmail.com>
 * @param {callback} cb - The next callback to keep the flow on all the 
 * &lt;b>prepare process&lt;/b> on the file.
 * 
 */
function writeRemainingJSONFiles(cb) {
  let each = require('async').each;
  const remainingJSONs = arrayModels.filter(model => model.hasToBeModifiedOrAdded);

  //Removed hasToBeModifiedOrAdded property to not write it on the JSON Seed files.
  remainingJSONs.forEach(json => delete json.hasToBeModifiedOrAdded);

  const jsonfile = require('jsonfile')

  each(remainingJSONs, (json, eachCallback) => {
    
    let file = `.${seedsDirectory}seed-${json.filename}`
    let obj = json

    jsonfile.writeFile(file, obj, { spaces: 2 }, function (err) {
      if (err) eachCallback(err);
      eachCallback();
    })

  }, err => {
    if (err) cb(err);
    else cb(null);

  })
}

module.exports = bootstrapFuction;</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Fri Jul 06 2018 14:43:43 GMT-0500 (CDT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
